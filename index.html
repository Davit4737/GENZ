// === REPLACE the payBtn click handler with this block ===
payBtn.addEventListener('click', async ()=>{
  const usd = parseFloat(usdInput.value||0);
  const crypto = parseFloat(cryptoInput.value||0);
  // compute SOL amount (floating, keep decimals)
  let solAmount = crypto > 0 ? crypto : (usd > 0 ? (usd / rates.sol) : 0);
  if (!solAmount || solAmount <= 0){ resultLine.textContent = 'Enter an amount in USD or SOL.'; return; }

  // detect provider (Phantom)
  const provider = (window.solana && (window.solana.isPhantom ? window.solana : (Array.isArray(window.solana && window.solana.providers) ? window.solana.providers.find(p=>p.isPhantom) : null))) || null;

  // prefer provider: attempt to build+send transaction using Phantom extension/mobile-injected provider
  if (provider && provider.isPhantom){
    try{
      resultLine.textContent = 'Connecting to Phantom...';
      await provider.connect();

      const fromPubkey = provider.publicKey;
      if (!fromPubkey){
        resultLine.textContent = 'Failed to obtain public key from Phantom.';
        return;
      }

      resultLine.textContent = 'Building transaction...';
      const toPubkey = new solanaWeb3.PublicKey(SOL_ADDRESS);
      const lamports = Math.round(solAmount * solanaWeb3.LAMPORTS_PER_SOL);

      const tx = new solanaWeb3.Transaction().add(
        solanaWeb3.SystemProgram.transfer({
          fromPubkey: fromPubkey,
          toPubkey: toPubkey,
          lamports: lamports
        })
      );

      // set fee payer & recent blockhash
      tx.feePayer = fromPubkey;
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
      tx.recentBlockhash = blockhash;

      resultLine.textContent = 'Opening Phantom for signing...';

      // Try common methods in best-effort order
      if (typeof provider.sendTransaction === 'function'){
        const signature = await provider.sendTransaction(tx, connection);
        resultLine.innerHTML = 'Transaction sent, awaiting confirmation... txid: <code>' + signature + '</code>';
        const explorerUrl = 'https://explorer.solana.com/tx/' + signature + (NETWORK === 'devnet' ? '?cluster=devnet' : '');
        await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight }, 'confirmed');
        resultLine.innerHTML = 'Payment confirmed. <a href="' + explorerUrl + '" target="_blank" rel="noopener noreferrer">View in Explorer</a><br><small>txid: ' + signature + '</small>';
        if (overlay._ratesInterval) { clearInterval(overlay._ratesInterval); overlay._ratesInterval = null; }
        return;
      } else if (typeof provider.signAndSendTransaction === 'function'){
        const signed = await provider.signAndSendTransaction(tx);
        const signature = signed && (signed.signature || signed);
        resultLine.innerHTML = 'Transaction sent, awaiting confirmation... txid: <code>' + signature + '</code>';
        const explorerUrl = 'https://explorer.solana.com/tx/' + signature + (NETWORK === 'devnet' ? '?cluster=devnet' : '');
        await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight }, 'confirmed');
        resultLine.innerHTML = 'Payment confirmed. <a href="' + explorerUrl + '" target="_blank" rel="noopener noreferrer">View in Explorer</a><br><small>txid: ' + signature + '</small>';
        if (overlay._ratesInterval) { clearInterval(overlay._ratesInterval); overlay._ratesInterval = null; }
        return;
      } else if (typeof provider.signTransaction === 'function'){
        const signedTx = await provider.signTransaction(tx);
        const raw = signedTx.serialize();
        const signature = await connection.sendRawTransaction(raw, { skipPreflight: false });
        resultLine.innerHTML = 'Transaction sent, awaiting confirmation... txid: <code>' + signature + '</code>';
        const explorerUrl = 'https://explorer.solana.com/tx/' + signature + (NETWORK === 'devnet' ? '?cluster=devnet' : '');
        await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight }, 'confirmed');
        resultLine.innerHTML = 'Payment confirmed. <a href="' + explorerUrl + '" target="_blank" rel="noopener noreferrer">View in Explorer</a><br><small>txid: ' + signature + '</small>';
        if (overlay._ratesInterval) { clearInterval(overlay._ratesInterval); overlay._ratesInterval = null; }
        return;
      } else {
        resultLine.textContent = 'Phantom found but does not support required signing methods. Consider updating Phantom.';
      }
    } catch (err){
      console.error(err);
      resultLine.textContent = 'Error while using Phantom provider: ' + (err && err.message ? err.message : String(err));
    }
    return;
  }

  // If we reach here — provider not found. Use Phantom universal deeplink.
  // Build deeplink: https://phantom.app/ul/transfer?address=ADDRESS&amount=AMOUNT
  // Add cluster param for devnet if you're testing.
  const amountStr = String(Number(solAmount)); // ensure decimal format
  let deeplink = 'https://phantom.app/ul/transfer?address=' + encodeURIComponent(SOL_ADDRESS) + '&amount=' + encodeURIComponent(amountStr);
  if (NETWORK === 'devnet') deeplink += '&cluster=devnet';

  // Open deeplink in new window/tab — on mobile this should open the app. On desktop it goes to phantom page.
  try {
    window.open(deeplink, '_blank');
    resultLine.innerHTML = 'No Phantom extension detected. Opening Phantom link — users on mobile should see the app. <br>If nothing opens, copy this address and amount and paste into your wallet: <br><code>' + SOL_ADDRESS + '</code> — ' + amountStr + ' SOL';
  } catch (e){
    resultLine.innerHTML = 'Failed to open Phantom link. Copy address: <code>' + SOL_ADDRESS + '</code> — ' + amountStr + ' SOL';
  }
});
